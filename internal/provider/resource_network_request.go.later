package provider

import (
	"context"
	"fmt"
	"strconv"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/public-cloud-wl/terraform-provider-gcsreferential/internal/provider/connector"
	"github.com/public-cloud-wl/tools/cidrCalculator"
)

type networkRequestResource struct{}

// Metadata implements resource.Resource.
func (r *networkRequestResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_network_request"
}

type networkRequestResourceModel struct {
	PrefixLength types.Int64  `tfsdk:"prefix_length"`
	BaseCidr     types.String `tfsdk:"base_cidr"`
	NetmaskId    types.String `tfsdk:"netmask_id"`
	Netmask      types.String `tfsdk:"netmask"`
	Id           types.String `tfsdk:"id"`
}

func NewNetworkRequestResource() resource.Resource {
	return &networkRequestResource{}
}

func (r *networkRequestResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "network_request",
		Attributes: map[string]schema.Attribute{
			"prefix_length": schema.Int64Attribute{
				MarkdownDescription: "The prefix of the requested network for example with 24 a /24 subnet will be booked by the network_request",
				Required:            true,
			},
			"base_cidr": schema.StringAttribute{
				MarkdownDescription: "The supernet where to do the network_request, for example 10.0.0.0/8",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"netmask_id": schema.StringAttribute{
				MarkdownDescription: "The netmask_id that you will associate to your network_request",
				Required:            true,
			},
			"netmask": schema.StringAttribute{
				MarkdownDescription: "The reserved netmask as full cidr, for example 10.12.13.0/24",
				Computed:            true,
			},
			"id": schema.StringAttribute{
				MarkdownDescription: "The terraform id associate to your network_request, it will be netmask_id if it exist",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
		},
	}
}

func (r *networkRequestResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var diags diag.Diagnostics
	// Call the existing inner function for create logic
	err := innerResourceServerCreate(ctx, req, resp)
	if err != nil {
		resp.Diagnostics.AddError("Error creating resource", err.Error())
		return
	}
	resp.Diagnostics = diags
}

func (r *networkRequestResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data networkRequestResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
	// Call the existing inner function for read logic
	idContent := strings.Split(data.Id.ValueString(), ":")
	reservatorBucket := idContent[0]
	baseCidr := idContent[1]
	netmaskId := idContent[2]
	gcpConnector := connector.NewNetwork(reservatorBucket, baseCidr)
	networkConfig, err := gcpConnector.ReadRemote(ctx)
	if err != nil {
		resp.Diagnostics.AddError("Error reading resource", err.Error())
		return
	}
	subnet, contains := networkConfig.Subnets[netmaskId]
	if !contains {
		resp.Diagnostics.AddError("Netmask not found", fmt.Sprintf("Netmask with id %s does not exist!", netmaskId))
		return
	}
	prefixLength, _ := strconv.ParseInt(strings.Split(subnet, "/")[1], 10, 64)
	data.BaseCidr = types.StringValue(baseCidr)
	data.NetmaskId = types.StringValue(netmaskId)
	data.PrefixLength = types.Int64Value(prefixLength)
	data.Netmask = types.StringValue(subnet)
	resp.Diagnostics.Append(resp.State.Get(ctx, &data)...)
}

func (r *networkRequestResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data networkRequestResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
	// Call the existing inner function for update logic
	err := innerResourceServerUpdate(ctx, req, resp)
	if err != nil {
		resp.Diagnostics.AddError("Error updating resource", err.Error())
		return
	}
}

func (r *networkRequestResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data networkRequestResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
	// Call the existing inner function for delete logic
	err := innerResourceServerDelete(ctx, req, resp)
	if err != nil {
		resp.Diagnostics.AddError("Error deleting resource", err.Error())
		return
	}
}

func (r *networkRequestResource) importState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	/* OLD FUNCTION

	var data networkRequestResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}
	idContent := strings.Split(data.NetmaskId.String(), ":")
	reservatorBucket := idContent[0]
	baseCidr := idContent[1]
	netmaskId := idContent[2]
	gcpConnector := connector.NewNetwork(reservatorBucket, baseCidr)
	networkConfig, err := gcpConnector.ReadRemote(ctx)
	if err != nil {
		return nil, err
	}
	subnet, contains := networkConfig.Subnets[netmaskId]
	if !contains {
		return nil, errors.New(fmt.Sprintf("Netmask with id %s does not exist!", netmaskId))
	}
	prefixLength, _ := strconv.ParseInt(strings.Split(subnet, "/")[1], 10, 64)
	data.BaseCidr = types.StringValue(baseCidr)
	data.NetmaskId = types.StringValue(netmaskId)
	data.PrefixLength = types.Int64Value(prefixLength)
	return []*networkRequestResourceModel{data}, nil

	END OF OLD FUNCTION */
	resource.ImportStatePassthroughID(ctx, path.Root("netmask_id"), req, resp)
}

func readRemoteNetwork(ctx context.Context, p GCSReferentialProviderModel, data networkRequestResourceModel) (*connector.NetworkConfig, *connector.GcpConnectorNetwork, error) {
	cidrProviderBucket := p.referentialBucket.String()
	gcpConnector := connector.NewNetwork(cidrProviderBucket, data.BaseCidr.String())
	networkConfig, err := gcpConnector.ReadRemote(ctx)
	if err != nil {
		if err.Error() == "storage: object doesn't exist" {
			err = nil
			networkConfig = &connector.NetworkConfig{Subnets: make(map[string]string)}
		} else {
			return nil, nil, err
		}
	}
	//netmaskId := data.Get("netmask_id").(string)
	//data.SetId("")
	//if netmask, contains := networkConfig.Subnets[netmaskId]; contains {
	//	data.SetId(netmaskId)
	//	err = data.Set("netmask", netmask)
	//	if err != nil {
	//		return nil, nil, err
	//	}
	//}
	return networkConfig, &gcpConnector, nil
}

func innerResourceServerCreate(ctx context.Context, data *networkRequestResourceModel, m interface{}) func() error {
	return func() error {
		networkConfig, gcpConnector, err := readRemoteNetwork(ctx, *data)
		if err != nil {
			return err
		}
		if data.Get("id") != nil {
			return nil
		}
		netmaskId := data.Get("netmask_id").(string)
		if _, contains := networkConfig.Subnets[netmaskId]; contains {
			return fmt.Errorf("The netmaskId %s already exists, but does not belong to your Terraform state!!!", netmaskId)
		}
		prefixLength := int8(data.Get("prefix_length").(int))
		if err != nil {
			return err
		}
		newCidrCalculator, err := cidrCalculator.New(&networkConfig.Subnets, prefixLength, gcpConnector.BaseCidrRange)
		if err != nil {
			return err
		}
		nextNetmask, err := newCidrCalculator.GetNextNetmask()
		if err != nil {
			return err
		}
		networkConfig.Subnets[netmaskId] = nextNetmask
		//err = gcpConnector.Recursiveutils.retryReadWrite
		err = gcpConnector.WriteRemote(networkConfig, ctx)
		if err != nil {
			return err
		}
		data.SetId(fmt.Sprintf("%s:%s:%s", gcpConnector.BucketName, gcpConnector.BaseCidrRange, netmaskId))
		err = data.Set("netmask", nextNetmask)
		if err != nil {
			return err
		}
		return nil
	}
}

// TODO: if netmask_id already exists, which does not belong to THIS state, throw error.
// TODO: Update of netmask_id should not enforce recreate.
func innerResourceServerUpdate(ctx context.Context, data *networkRequestResourceModel, m interface{}) func() error {
	return func() error {
		networkConfig, gcpConnector, err := readRemoteNetwork(ctx, data, m)
		if err != nil {
			return err
		}
		id := data.Id()
		valuesFromId := strings.Split(id, ":")
		netmaskId := data.Get("netmask_id").(string)
		netmaskIdFromId := valuesFromId[2]
		currentSubnet := networkConfig.Subnets[netmaskIdFromId]
		if netmaskIdFromId != netmaskId {
			delete(networkConfig.Subnets, netmaskIdFromId)
			if _, contains := networkConfig.Subnets[netmaskId]; contains {
				return fmt.Errorf("The netmaskId %s already exists, but does not belong to your Terraform state!!!", netmaskId)
			}
			networkConfig.Subnets[netmaskId] = currentSubnet
		}
		currentPrefixLength, err := strconv.ParseInt(strings.Split(currentSubnet, "/")[1], 10, 8)
		if err != nil {
			return err
		}
		prefixLength := int8(data.Get("prefix_length").(int))
		baseCidrRangeFromId := valuesFromId[1]
		if (baseCidrRangeFromId != gcpConnector.BaseCidrRange) || (int8(currentPrefixLength) != prefixLength) {
			newCidrCalculator, err := cidrCalculator.New(&networkConfig.Subnets, int8(prefixLength), gcpConnector.BaseCidrRange)
			if err != nil {
				return err
			}
			nextNetmask, err := newCidrCalculator.GetNextNetmask()
			if err != nil {
				return err
			}
			networkConfig.Subnets[netmaskId] = nextNetmask
			err = data.Set("netmask", nextNetmask)
			if err != nil {
				return err
			}
		}
		err = gcpConnector.WriteRemote(networkConfig, ctx)
		if err != nil {
			return err
		}
		data.SetId(fmt.Sprintf("%s:%s:%s", gcpConnector.BucketName, gcpConnector.BaseCidrRange, netmaskId))
		return nil
	}
}

func innerResourceServerDelete(ctx context.Context, data *networkRequestResourceModel, m interface{}) func() error {
	return func() error {
		networkConfig, gcpConnector, err := readRemoteNetwork(ctx, data, m)
		if err != nil {
			return err
		}
		netmaskId := data.Get("netmask_id").(string)
		delete(networkConfig.Subnets, netmaskId)
		err = gcpConnector.WriteRemote(networkConfig, ctx)
		if err != nil {
			return err
		}
		return nil
	}
}
